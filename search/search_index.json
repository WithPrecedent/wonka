{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"wonka","text":"Version Status Documentation Tools Compatibility Stats"},{"location":"#what-is-wonka","title":"What is wonka?","text":"<p><code>wonka</code><sup>1</sup> is an extensible library for simple implementation of class and object constructors in Python. Out-of-the-box, <code>wonka</code> has implementations of several common creational design patterns, including: registry factories, prototypers, and composite builder workflows. It is also easy to extend <code>wonka</code> by adding your own custom factories<sup>2</sup> while taking advantage of <code>wonka</code>'s convenient mixin classes and helper functions.</p> <p>This readme offers a basic outline of how <code>wonka</code> works. If you would prefer to jump right into the full documentation, go here.</p>"},{"location":"#why-use-wonka","title":"Why use wonka?","text":"<p>\u201cNo other factory in the world mixes its chocolate by waterfall\u2026 But it\u2019s the only way if you want it just right.\u201d - Willy Wonka</p> <p>Factories are essential components of coding projects that require dynamic, runtime implementation of different strategies or options. In Python packages, despite their commmon usage, factories are often poorly implemented, fragile, or inflexible. <code>wonka</code> addresses those common shortcomings by offering convenient creation through a simple, adaptable system that has almost no learning curve<sup>3</sup>. <code>wonka</code> is:</p> <ul> <li>Intuitive: factories use a common interface with a <code>create</code> class method for all construction operations.</li> <li>Extensible: core classes can be adapted and extended through inheritance or composition.</li> <li>Flexible: whenever possible, factories can be mixed in for class and object self-creation or be used for creating external items.</li> <li>Lightweight: the library has a miniscule memory footprint with few dependencies.</li> <li>Robust: \"turn-key\" factories handle edge cases and core scenarios without needing further tinkering.</li> <li>Accessible: <code>wonka</code> is over-documented to make it accessible to beginnning coders and readily usable for developers at all levels.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#installation","title":"Installation","text":"<p>To install <code>wonka</code>, use <code>pip</code>:</p> <pre><code>pip install wonka\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>There are three categories of base classes in <code>wonka</code>: factories, managers, and producers. Each is described in greater detail below.</p>"},{"location":"#factories","title":"Factories","text":"<p>All <code>wonka</code> factory classes have a <code>create</code> class method which is used to construct new items. The only required argument for <code>create</code> is <code>item</code>, which contains the data for building products.</p> <p>Out-of-the-box, this library offers three general subtypes of its base <code>Factory</code> class. These are not subclasses, but rather describe the type of functionality in the included <code>Factory</code> subclasses.</p> <ul> <li>Registries - factories that build classes or objects from explicit or implicit registries.</li> <li>Dispatchers - factories that call appropriate creation methods or functions based on the type or content of data passed.</li> <li>Prototypers - factories that clone exsting classes or objects.</li> </ul>"},{"location":"#managers","title":"Managers","text":"<p>For more complex construction, you can use subclasses of <code>Manager</code>, which is an iterable constructor. Every <code>Manager</code> subclass may construct items in three ways:</p> <ol> <li>Calling its <code>manage</code> method.</li> <li>Calling its <code>create</code> method (which just calls the <code>manage</code> method, but this allows a <code>Manager</code> subclass instance to be used anywhere a <code>Factory</code> could be used while still being distinguishable from an ordinary <code>Factory</code>).</li> <li>Iterating it directly.</li> </ol>"},{"location":"#producers","title":"Producers","text":"<p>As another optional feature, <code>wonka</code> supports post-construction modification of built items through subclasses of <code>Producer</code>. This is particularly important for factories that use other resources (such as registries). <code>wonka</code> separates concerns so that the return value can be modified through a simple mixin system. This division of labor makes it incredibly easy to put together a <code>Factory</code> or <code>Manager</code> with a <code>Producer</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<p>If <code>wonka</code> does not fit your needs, you might find one of these other packages helpful. None of them does the same things that <code>wonka</code> does (which is why I created this library), but they might fit your particular project needs better.</p> <p> </p> <ul> <li>dataclass_factory: factory for dataclass production from other common data types.</li> <li>factory_boy: tool for dynamically creating objects for unit testing in Python.</li> <li>Model Bakery: object factory for Django.</li> <li>Polyfactory: factory framework for mock data generation.</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>I would like to thank the University of Kansas School of Law for tolerating and supporting this law professor's coding efforts, an endeavor which is well outside the typical scholarly activities in the discipline.</p> <p>Lastly, I want to extend a special thanks to the late, great Gene Wilder, whose work inspired the name of this project and made my childhood better.</p> <p> </p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p> <ol> <li> <p>This project is not affiliated with Willy Wonka candy, either of the Willy Wonka films (especially the Johnny Depp one), or any other Willy Wonka product. It's just named \"wonka\" because all of the most obvious names for a Python package of factories and other constructors on pypi.org were taken and Willy Wonka's insane candy factory was the first relevant pop-culture touchstone I could think of.\u00a0\u21a9</p> </li> <li> <p>For the sake of brevity, the documentation refers to all of <code>wonka</code>'s constructors as \"factories,\" even though many do not fit the definition of the classic factory design pattern.\u00a0\u21a9</p> </li> <li> <p>Chocolate waterfalls are, sadly, only virtually implemented in <code>wonka</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#020-forthcoming","title":"0.2.0 (forthcoming)","text":"<ul> <li>Added example to README.md</li> <li>Added more recipes to recipes.md</li> <li>Added Registry class, offering extra functionality beyond a <code>dict</code></li> <li>Added documentation to advanced.md</li> <li>Added support for Python 3.13</li> <li>Changed 'Manager' 'create' property to a proper alias method for 'manage' to preserve its signature when introspected</li> </ul>"},{"location":"changelog/#015","title":"0.1.5","text":"<ul> <li>Fixed default for 'Registrar' registry class attribute</li> <li>Fixed wordwrap issue in tables in tutorial</li> <li>Added recipe to recipes.md</li> <li>Removed non-public classes and functions from documentation</li> <li>Fixed bug with Manager's <code>create</code> property so that it properly calls the   <code>manage</code> method</li> <li>Changed required Python version to 3.11 or greater</li> </ul>"},{"location":"changelog/#014","title":"0.1.4","text":"<ul> <li>Removed empty keystons module until it is ready to prevent linting errors</li> <li>Updated out-of-date actions</li> <li>Removed extraneous actions</li> </ul>"},{"location":"changelog/#013","title":"0.1.3","text":"<ul> <li>Fixed unit test setting bug</li> </ul>"},{"location":"changelog/#012","title":"0.1.2","text":"<ul> <li>Transitioned to 0.1.9 <code>snickerdoodle</code> template</li> <li>Removed all external dependencies</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<ul> <li>Added unit tests</li> <li>Added advanced documentation and full tutorial</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial commit</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build wonka. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>~=2.10</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.2.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>&gt;= 7.2.7</code> <code>7.3.1</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.7</code> PSF-2.0 <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.12.4</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.36</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.35</code> <code>0.36.2</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.5.29</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.9</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.4.4</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;= 0.3</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;= 1.6.0</code> <code>1.6.0</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>2.1.3</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;= 1.5.2</code> <code>1.5.3</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;= 1.0.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;= 0.5.0</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of github committers and other useful GIT info such as last modified date <code>&gt;= 1.1.2</code> <code>1.2.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;= 0.6.0</code> <code>0.6.1</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;= 9.1.2</code> <code>9.3.2</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.1</code> <code>1.2</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;= 0.7.1</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python] &gt;= 0.22.0</code> <code>0.23.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.7.0</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.8.0</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>3.10.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>&gt;= 3.3.3</code> <code>3.4.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.3</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;= 7.4.0</code> <code>7.4.2</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;= 4.1.0</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;= 3.13.0</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;= 3.3.1</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>~=2022.4</code> <code>2022.10.31</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;= 0.0.286</code> <code>0.0.290</code> MIT <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>68.2.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.1</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.5</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;= 0.10.2</code> <code>0.10.2</code> MIT <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.5</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.24.5</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2023, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#sourcerer-recipe-for-accepting-different-data-types","title":"<code>Sourcerer</code> Recipe for Accepting Different Data Types","text":"<p>This example is simplified adaptation from the <code>bobbie</code> configuration settings repository. This code sets up a Settings class that will call a different construction method depending on the type of data passed:</p> <pre><code>import configparser\nimport dataclasses\nimport pathlib\nfrom collections.abc import Callable, MutableMapping\nfrom typing import Any, ClassVar\nimport yaml\nimport wonka\n_FILE_EXTENSIONS: dict[str, str] = {\n'ini': 'ini',\n'yaml': 'yaml',\n'yml': 'yaml'}\n_LOAD_METHOD: Callable[[str], str] = lambda x: f'from_{x}'\n@dataclasses.dataclass\nclass Settings(wonka.Sourcerer):\ncontents: MutableMapping[str, Any] = dataclasses.field(\ndefault_factory = dict)\nsources: ClassVar[MutableMapping[type[Any], str]] = {\npathlib.Path: 'file',\nstr: 'file',\nMutableMapping: 'dict'}\n@classmethod\ndef from_dict(cls, source: MutableMapping[str, Any]) -&gt; Settings:\nreturn cls(source)\n@classmethod\ndef from_file(cls, source: str | pathlib.Path) -&gt; Settings:\nif isinstance(source, str):\nsource = pathlib.Path(item)\nif source.is_file():\n# Gets file extension and looks up the appropriate function to call.\nextension = source.suffix[1:]\nfile_type = _FILE_EXTENSIONS[extension]\nname = _LOAD_METHOD(file_type)\ntry:\nreturn getattr(cls, name)(source)\nexcept AttributeError as error:\nmessage = f'Loading from {file_type} file is not supported'\nraise TypeError(message) from error\nelse:\nmessage = f'settings file {source} not found'\nraise FileNotFoundError(message)\n@classmethod\ndef from_ini(cls, source: str | pathlib.Path) -&gt; Settings:\nif isinstance(source, str):\nsource = pathlib.Path(item)\ntry:\ncontents = configparser.ConfigParser()\ncontents.optionxform = lambda option: option\ncontents.read(source)\nexcept (KeyError, FileNotFoundError) as error:\nmessage = f'settings file {source} not found'\nraise FileNotFoundError(message) from error\nreturn cls(contents)\n@classmethod\ndef from_yaml(cls, source: str | pathlib.Path) -&gt; Settings:\nif isinstance(source, str):\nsource = pathlib.Path(item)\ntry:\nwith open(source) as config:\ncontents = yaml.safe_load(config)\nexcept FileNotFoundError as error:\nmessage = f'settings file {path} not found'\nraise FileNotFoundError(message) from error\nreturn cls(contents)\n</code></pre> <p>The <code>Settings</code> class inherits the <code>create</code> class method from <code>wonka.Sourcerer</code>. So, the user just needs to pass a file or <code>dict</code> to the <code>create</code> classmethod and it will return a <code>Settings</code>. So, if your settings are stored in an <code>ini</code> file, you just used this code:</p> <pre><code>settings = Settings.create('configuration.ini')\n</code></pre> <p>Or, if you have the settings in a Python <code>dict</code> named <code>configuration</code>, you just do this:</p> <pre><code>configuration = {\n'general': {\n'verbose': True,\n'seed': 43},\n'tasks': {\n'things_to_do': ['stop', 'drop', 'roll']},\n'tasks_parameters': {\n'start': 'when_ready',\n'end': 'when_done'}}\nsettings = Settings.create(configuration)\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>There are three categories of base classes in <code>wonka</code>: factories, managers, and producers. Each is described in greater detail below.</p>"},{"location":"tutorial/#factories","title":"Factories","text":"<p>Out-of-the-box, this library offers three general subtypes of its base <code>Factory</code> class. These are not subclasses, but rather describe the kind of functionality in the included <code>Factory</code> subclasses.</p> <ul> <li>Registries - factories that build classes or objects from explicit or implicit registries.</li> <li>Dispatchers - factories that call appropriate creation methods or functions based on the type or content of data passed.</li> <li>Prototypers - factories that clone exsting classes or objects.</li> </ul> <p>Here are the included factories:</p> Factory Subtype Produces Description Registrar Registry Class or Instance Creates items from data in <code>registry</code> Subclasser Registry Subclass Like <code>Registrar</code>, but without the <code>registry</code> attribute Sourcerer Dispatcher Class or Instance Calls the appropriate creation class method from data in <code>sources</code> Delegate Dispatcher Class or Instance Like <code>Sourcerer</code>, but without <code>sources</code> Scribe Prototyper Class or Instance Makes a deep copy of an item"},{"location":"tutorial/#managers","title":"Managers","text":"<p>These are the Manager classes included in <code>wonka</code>:</p> Manager Manages Produces Description Assembler Factory Classes, Factory Instances, and/or other Manager Instances Class(es) and/or Instance(s) A linear constructer, like an assembly line"},{"location":"tutorial/#producers","title":"Producers","text":"<p>These are the basic producers provied by <code>wonka</code>:</p> Producer Mixes With Produces Description Classer Factory or Manager Class <code>create</code> method always returns a class Flexer Factory or Manager Class or Instance <code>create</code> returns a class or instance, depending on data passed Instancer Factory or Manager Instance <code>create</code> method always returns an instance"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> wonka<ul> <li> base</li> <li> clusters</li> <li> dispatchers</li> <li> managers</li> <li> options</li> <li> producers</li> <li> prototypers</li> <li> registries</li> <li> shared</li> <li> utilities</li> </ul> </li> </ul>"},{"location":"reference/wonka/","title":"Index","text":"<p>Flexible, accessible, extensible Python factories</p>"},{"location":"reference/wonka/#wonka.Assembler","title":"<code>Assembler</code>  <code>dataclass</code>","text":"<p>             Bases: <code>MutableSequence</code>, <code>Manager</code></p> <p>Assembly line constructer.</p> <p>Assembler stores a sequence of wonka constructors that are called by the <code>manage</code> (or <code>create</code>) method in order to construct an item.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Constructor]</code> <p>stored constructors. Defaults to an empty list.</p> <code>field(default_factory=list)</code>"},{"location":"reference/wonka/#wonka.Assembler.contents","title":"<code>contents: MutableSequence[base.Constructor] = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/wonka/#wonka.Assembler.add","title":"<code>add(item)</code>","text":"<p>Adds <code>item</code> to the <code>contents</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Constructor | Sequence[Constructor]</code> <p>item(s) to add to <code>contents</code> attribute.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if all of the values of <code>item</code> are not wonka-compatible constructors.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def add(self, item: base.Constructor | Sequence[base.Constructor]) -&gt; None:\n\"\"\"Adds `item` to the `contents` attribute.\n    Args:\n        item: item(s) to add to `contents` attribute.\n    Raises:\n        TypeError: if all of the values of `item` are not wonka-compatible\n            constructors.\n    \"\"\"\nif shared.is_constructor(item):\nself.contents.append(item)\nelif (isinstance(item, Sequence)\nand all(shared.is_constructor(v) for v in item)):\nself.contents.extend(item)\nelse:\nraise TypeError(\n'All values in item must be wonka-compatible constructors')\n</code></pre>"},{"location":"reference/wonka/#wonka.Assembler.delete","title":"<code>delete(item)</code>","text":"<p>Deletes item at the index in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>index in <code>contents</code> to delete.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def delete(self, item: int) -&gt; None:\n\"\"\"Deletes item at the index in `contents`.\n    Args:\n        item: index in `contents` to delete.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/wonka/#wonka.Assembler.insert","title":"<code>insert(index, item)</code>","text":"<p>Inserts <code>item</code> at <code>index</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index to insert <code>item</code> at.</p> required <code>item</code> <code>Any</code> <p>object to be inserted.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def insert(self, index: int, item: Any) -&gt; None:\n\"\"\"Inserts `item` at `index` in `contents`.\n    Args:\n        index: index to insert `item` at.\n        item: object to be inserted.\n    \"\"\"\nself.contents.insert(index, item)\nreturn\n</code></pre>"},{"location":"reference/wonka/#wonka.Assembler.manage","title":"<code>manage(item)</code>","text":"<p>Manages construction and/or modification based on <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to constructors in <code>contents</code>.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def manage(self, item: Any) -&gt; Any:\n\"\"\"Manages construction and/or modification based on `item`.\n    Args:\n        item: item to be passed to constructors in `contents`.\n    Returns:\n        Constructed item.\n    \"\"\"\nfor constructor in self.contents:\nitem = constructor.create(item)\nreturn item\n</code></pre>"},{"location":"reference/wonka/#wonka.Assembler.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends <code>item</code> to <code>contents</code>.</p> <p>If <code>item</code> is a non-<code>str</code> sequence, <code>prepend</code> adds its contents to the stored list in the order they appear in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to prepend to <code>contents</code>.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def prepend(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Prepends `item` to `contents`.\n    If `item` is a non-`str` sequence, `prepend` adds its contents to the\n    stored list in the order they appear in `item`.\n    Args:\n        item: item(s) to prepend to `contents`.\n    \"\"\"\nif utilities._is_sequence(item = item):\nfor thing in reversed(item):\nself.prepend(item = thing)\nelse:\nself.insert(0, item)\nreturn\n</code></pre>"},{"location":"reference/wonka/#wonka.Assembler.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of <code>contents</code>.</p> <p>This method applies <code>include</code> before <code>exclude</code> if both are passed. If <code>include</code> is None, all existing items will be added to the new subset class instance before <code>exclude</code> is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Any | Sequence[Any] | None</code> <p>item(s) to include in the new instance. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Any | Sequence[Any] | None</code> <p>item(s) to exclude in the new instance. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>include</code> and <code>exclude</code> are both None.</p> <p>Returns:</p> Type Description <code>Assembler</code> <p>Assembler with only items from <code>include</code> and no items in <code>exclude</code>.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def subset(\nself,\ninclude: Any | Sequence[Any] | None = None,\nexclude: Any | Sequence[Any] | None = None) -&gt; Assembler:\n\"\"\"Returns a new instance with a subset of `contents`.\n    This method applies `include` before `exclude` if both are passed. If\n    `include` is None, all existing items will be added to the new subset\n    class instance before `exclude` is applied.\n    Args:\n        include: item(s) to include in the new instance. Defaults to None.\n        exclude: item(s) to exclude in the new instance. Defaults to None.\n    Raises:\n        ValueError: if `include` and `exclude` are both None.\n    Returns:\n        Assembler with only items from `include` and no items in `exclude`.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(utilities._iterify(include))\ncontents = [i for i in self.contents if i in include]\nif exclude is not None:\nexclude = list(utilities._iterify(exclude))\ncontents = [i for i in contents if i not in exclude]\nnew_listing = copy.deepcopy(self)\nnew_listing.contents = contents\nreturn new_listing\n</code></pre>"},{"location":"reference/wonka/#wonka.Classer","title":"<code>Classer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer with an <code>produce</code> method always return a class.</p>"},{"location":"reference/wonka/#wonka.Classer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>. The argument for <code>parameters</code> is ignored by <code>Classer</code> - it is only included to provide a consistent interface across all <code>Producer</code> subclasses.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`. The argument for `parameters` is ignored by\n            `Classer` - it is only included to provide a consistent\n            interface across all `Producer` subclasses.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nreturn item if inspect.isclass(item) else item.__class__\n</code></pre>"},{"location":"reference/wonka/#wonka.Delegate","title":"<code>Delegate</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Builds based on the <code>str</code> name of the type passed.</p> <p>This factory acts as a dispatcher to call creation methods based on the type or name of the type passed in a manner identical to <code>Sourcerer</code>. However, unlike <code>Sourcerer</code>, <code>Delegate</code> only finds a matching creation method if the <code>str</code> name of the type of <code>item</code> matches a substring of the creation method name using the format of <code>configuration._METHOD_NAMER</code>.</p>"},{"location":"reference/wonka/#wonka.Delegate.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an appropriate method does not exist for the data type of <code>item.</code></p> <code>KeyError</code> <p>If a corresponding subclass does not exist for <code>item.</code></p> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to take kwargs.\n    Raises:\n        AttributeError: If an appropriate method does not exist for the\n            data type of `item.`\n        KeyError: If a corresponding subclass does not exist for `item.`\n    Returns:\n        Created item.\n    \"\"\"\nbuilder = _get_creation_method_name(item)\nitem = _get_from_builder_method(\nfactory = cls,\nmethod = builder,\nsource = item,\n**kwargs)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Factory","title":"<code>Factory</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base for <code>wonka</code> constructors.</p> <p>A <code>wonka</code> <code>Factory</code> can be subclassed into any constructer design (not just those that fit the classical factory design pattern). So, for example, the <code>wonka</code> package itself includes <code>Factory</code> subclasses that fit the prototype (<code>Scribe</code>), registry (<code>Registar</code> and<code>Subclasser</code>), and traditional factory (<code>Delegate</code> and <code>Sourcerer</code>) design patterns. Further, a <code>Manager</code> class instance may act as the director in a builder design pattern.</p> <p>One of the goals of <code>wonka</code>, though, is not be be wedded to or worried about the underlying design pattern. Instead, all constructers follow the simple, universal, and easily extensible interface of <code>Factory</code>.</p> <p>If you want to add code that modifies output of a <code>Factory</code>'s <code>create</code> class method, you can either include that in the subclass <code>create</code> method or by mixing in a <code>Producer</code> class. Details on how to use <code>Producer</code> subclasses are included in its documentation.</p>"},{"location":"reference/wonka/#wonka.Factory.create","title":"<code>create(item, **kwargs)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns a created or modified item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for creation of an item or an item to be modified.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef create(cls, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Returns a created or modified item.\n    Args:\n        item: data for creation of an item or an item to be modified.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Created item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/#wonka.Flexer","title":"<code>Flexer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer that conditions return value of the <code>produce</code> method.</p> <p>If <code>parameters</code> are passed to the <code>produce</code> method, an instance is always returned. If no <code>parameters</code> are passed, the item will be returned as-is (depending on the constructor used).</p>"},{"location":"reference/wonka/#wonka.Flexer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nif parameters is None:\nreturn item\nelif inspect.isclass(item):\nreturn item(**parameters)\nelse:\nreturn shared.inject_attributes(item, parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Instancer","title":"<code>Instancer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer with an <code>produce</code> method always return an instance.</p>"},{"location":"reference/wonka/#wonka.Instancer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nif inspect.isclass(item) and parameters is None:\nreturn item()\nelif parameters is None:\nreturn item\nelif inspect.isclass(item):\nreturn item(**parameters)\nelse:\nreturn shared.inject_attributes(item, parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Manager","title":"<code>Manager</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Iterable</code>, <code>ABC</code></p> <p>Base for manageing complex class or object construction.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Iterable</code> <p>an iterable containing <code>Factory</code> subclasses or <code>Manager</code> subclass instances.</p> required"},{"location":"reference/wonka/#wonka.Manager.contents","title":"<code>contents: Iterable</code>  <code>instance-attribute</code>","text":"<p>Required Subclass Methods</p>"},{"location":"reference/wonka/#wonka.Manager.create","title":"<code>create(item, **kwargs)</code>","text":"<p>Calls <code>manage</code> method.</p> <p>This method is included as a convenience so that an instance of a <code>Manager</code> can be used as a drop-in for a <code>Factory</code> subclass. <code>Manager</code> cannot easily be made a subclass for <code>Factory</code> because it will often need to rely on instance data for construction. So, every <code>Manager</code> subclass should be designed such that an instance of that subclass could be substituted for a <code>Factory</code> subclass. This allows other <code>Manager</code> subclass instances to be stored in <code>contents</code> as part of an iterable workflow.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to factories in <code>contents</code>.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>def create(self, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Calls `manage` method.\n    This method is included as a convenience so that an instance of a\n    `Manager` can be used as a drop-in for a `Factory` subclass. `Manager`\n    cannot easily be made a subclass for `Factory` because it will often\n    need to rely on instance data for construction. So, every `Manager`\n    subclass should be designed such that an instance of that subclass could\n    be substituted for a `Factory` subclass. This allows other `Manager`\n    subclass instances to be stored in `contents` as part of an iterable\n    workflow.\n    Args:\n        item: item to be passed to factories in `contents`.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Constructed item.\n    \"\"\"\nreturn self.manage(item, **kwargs)\n</code></pre>"},{"location":"reference/wonka/#wonka.Manager.manage","title":"<code>manage(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Manages construction and/or modification based on <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to factories in <code>contents</code>.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@abc.abstractmethod\ndef manage(self, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Manages construction and/or modification based on `item`.\n    Args:\n        item: item to be passed to factories in `contents`.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Constructed item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/#wonka.Manufacturer","title":"<code>Manufacturer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Cluster</code></p> <p><code>dict</code>-like container of factories.</p> <p>A <code>Manufacturer</code> may serve as a one-stop spot for factories. Each factory need not be of the same subtype, as they pass the <code>is_constructor</code> test. The use of a <code>Manufacturer</code> is wholly optional - it is just a convenience offered by <code>wonka</code>. To access individual constructors, the following format should be used:</p> <pre><code>manufacturer_instance['constructor_name'].create(*args, **kwargs)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>ConstructorDict</code> <p>stored <code>dict</code> of <code>wonka</code> factories. Defaults to an empty <code>dict</code>.</p> <code>field(default_factory=dict)</code>"},{"location":"reference/wonka/#wonka.Manufacturer.contents","title":"<code>contents: base.ConstructorDict = dataclasses.field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/wonka/#wonka.Manufacturer.add","title":"<code>add(item)</code>","text":"<p>Adds <code>item</code> to the <code>contents</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ConstructorDict | Constructor</code> <p>factory or factories to add.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if all of the values of <code>item</code> are not <code>wonka</code>-compatible factories or if <code>item</code> itself is not a <code>wonka</code>-compatible factory.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def add(self, item: base.ConstructorDict | base.Constructor) -&gt; None:\n\"\"\"Adds `item` to the `contents` attribute.\n    Args:\n        item: factory or factories to add.\n    Raises:\n        TypeError: if all of the values of `item` are not `wonka`-compatible\n            factories or if `item` itself is not a `wonka`-compatible\n            factory.\n    \"\"\"\nif isinstance(item, MutableMapping):\nif all(shared.is_constructor(v) for v in item.values()):\nself.contents.update(item)\nelse:\nmessage = (\n'All values in item must be wonka-compatible constructors')\nraise TypeError(message)\nelif shared.is_constructor(item):\nkey = options._KEY_NAMER(item)\nself.contents.update({key: item})\nelse:\nmessage = (\n'item must either be a wonka-compatible constructor or a dict-'\n'like object with values that are constructors')\nraise TypeError(message)\n</code></pre>"},{"location":"reference/wonka/#wonka.Manufacturer.delete","title":"<code>delete(item)</code>","text":"<p>Deletes <code>item</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in <code>contents</code> to delete the key/value pair.</p> required Source code in <code>src/wonka/clusters.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes `item` in `contents`.\n    Args:\n        item: key in `contents` to delete the key/value pair.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/wonka/#wonka.Manufacturer.items","title":"<code>items()</code>","text":"<p>Emulates Python <code>dict</code> <code>items</code> method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>A <code>tuple</code> equivalent to <code>dict.items()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates Python `dict` `items` method.\n    Returns:\n        A `tuple` equivalent to `dict.items()`.\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values(), strict = True))\n</code></pre>"},{"location":"reference/wonka/#wonka.Manufacturer.keys","title":"<code>keys()</code>","text":"<p>Returns <code>contents</code> keys as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>A <code>tuple</code> equivalent to <code>dict.keys()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns `contents` keys as a `tuple`.\n    Returns:\n        A `tuple` equivalent to `dict.keys()`.\n    \"\"\"\nreturn tuple(self.contents.keys())\n</code></pre>"},{"location":"reference/wonka/#wonka.Manufacturer.values","title":"<code>values()</code>","text":"<p>Returns <code>contents</code> values as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>A tuple equivalent to <code>dict.values()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns `contents` values as a `tuple`.\n    Returns:\n        A tuple equivalent to `dict.values()`.\n    \"\"\"\nreturn tuple(self.contents.values())\n</code></pre>"},{"location":"reference/wonka/#wonka.Producer","title":"<code>Producer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base mixin for modifying items.</p> <p>A <code>Producer</code>'s <code>produce</code> method will automatically be called if it is mixed-in with any of the <code>Factory</code> classes in <code>wonka</code>. If you want a custom <code>Factory</code> subclass to similarly automatically check for a <code>produce</code> method, the easiest way to do that is to simply call the <code>finalize</code> function as your return value for the <code>Factory</code>'s <code>create</code> method as follows:</p> <pre><code>return wonka.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Producer.produce","title":"<code>produce(item, parameters=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef produce(\ncls,\nitem: Any,\nparameters: GenericDict | None = None) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to be modified.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n    Returns:\n        Any: modified item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/#wonka.Registrar","title":"<code>Registrar</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Builds an item from a registry.</p> <p>Attributes:</p> Name Type Description <code>registry</code> <code>GenericDict</code> <p>stores classes and/or instances to be used in item construction. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/wonka/#wonka.Registrar.registry","title":"<code>registry: base.GenericDict = {}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/wonka/#wonka.Registrar.create","title":"<code>create(item, parameters=None)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>name corresponding to a key in <code>registry</code>.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a corresponding item in <code>registry</code> does not exist for <code>item.</code></p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>created item.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: str,\nparameters: base.GenericDict | None = None) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item (Hashable): name corresponding to a key in `registry`.\n        parameters: keyword arguments to pass or add to a created instance.\n    Raises:\n        KeyError: If a corresponding item in `registry` does not exist for\n            `item.`\n    Returns:\n        Any: created item.\n    \"\"\"\nitem = _get_from_registry(item = item, registry = cls.registry)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Scribe","title":"<code>Scribe</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Base class for cloning classes or objects.</p>"},{"location":"reference/wonka/#wonka.Scribe.create","title":"<code>create(item=None, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Clones <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | None</code> <p>item to clone. If it is None, the <code>create</code> method assumes that it should clone itself. Defaults to None.</p> <code>None</code> <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Cloned item.</p> Source code in <code>src/wonka/prototypers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any | None = None,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Clones `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to clone. If it is None, the `create` method assumes that\n            it should clone itself. Defaults to None.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Cloned item.\n    \"\"\"\nitem = item or cls\nitem = copy.deepcopy(item)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.Sourcerer","title":"<code>Sourcerer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code>, <code>ABC</code></p> <p>Builds based on compatibility with keys in the <code>sources</code> class attribute.</p> <p>This factory acts as a dispatcher to call other methods based on the type passed. Unlike <code>Delegate</code>, <code>Sourcerer</code> is more forgiving by allowing the type passed to a subtype or instance of the type listed as a key in the <code>sources</code> class attribute.</p> <p>The name for a <code>Sourcerer</code> is spelled the way it is instead of \"Sorcerer\" because the <code>sources</code> attribute is used. This is inspired by the \"Divinity: Original Sin\" games where the magic users are called \"Sourcerers\" because they may manipulate the magical energy known as \"source\". https://divinity.fandom.com/wiki/Sourcerer</p> <p>Attributes:</p> Name Type Description <code>sources</code> <code>MutableMapping[type[Any], str]</code> <p><code>dict</code> with keys that are types and values are substrings of the names of methods to call when the key type is passed to the <code>create</code> method. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/wonka/#wonka.Sourcerer.sources","title":"<code>sources: MutableMapping[type[Any], str] = {}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/wonka/#wonka.Sourcerer.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to add additional parameters.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the value matching the key <code>item</code> does not correspond to a method in the <code>Sourcerer</code> subclass.</p> <code>KeyError</code> <p>if there is no key in <code>sources</code> matching the type for <code>item</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to add additional parameters.\n    Raises:\n        AttributeError: if the value matching the key `item` does not\n            correspond to a method in the `Sourcerer` subclass.\n        KeyError: if there is no key in `sources` matching the type for\n            `item`.\n    Returns:\n        Created item.\n    \"\"\"\nfor kind, substring in cls.sources.items():\nif _is_kind(item, kind):\nbuilder = _get_creation_method_name(substring)\nitem = _get_from_builder_method(\nfactory = cls,\nmethod = builder,\nsource = item,\n**kwargs)\nreturn shared.finalize(item = item, parameters = parameters)\nraise KeyError(f'{item} does not match any recognized types')\n</code></pre>"},{"location":"reference/wonka/#wonka.Subclasser","title":"<code>Subclasser</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code>, <code>ABC</code></p> <p>Builds a subclass without requiring a storage attribute.</p> <p>Unlike some other factories, this one does not require any class attributes. Instead, it relies on pre-existing data and lazily adds keys to create a registry facade.</p> <p>This factory uses the subclasses stored in <code>__subclasses__</code> class method that is automatically created with every class. It creates a <code>dict</code> on the fly with key names based on <code>configuration._KEY_NAMER</code>. Because of this, <code>Subclasser</code> should ordinarily be used as a mixin (although it could simply be subclassed, if you prefer).</p>"},{"location":"reference/wonka/#wonka.Subclasser.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>A subclass in the <code>__subclasses__</code> class method is selected based on the naming convention in <code>wonka._KEY_NAMER</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a corresponding subclass does not exist for <code>item.</code></p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>created item.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    A subclass in the `__subclasses__` class method is selected based on the\n    naming convention in `wonka._KEY_NAMER`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to take kwargs.\n    Raises:\n        KeyError: If a corresponding subclass does not exist for `item.`\n    Returns:\n        Any: created item.\n    \"\"\"\nkeyer = options._KEY_NAMER\nall_subclasses = _get_all_subclasses(cls)\nregistry = {keyer(s): s for s in all_subclasses}\nitem = _get_from_registry(item = item, registry = registry)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.finalize","title":"<code>finalize(item, parameters=None, factory=None)</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a factory that may need to be altered before being returned by the factory <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>factory</code> <code>type[Factory] | None</code> <p>the constructor used to create <code>item</code>. This need not be passed if <code>item</code> is also the factory for its creation. Defaults to <code>None</code>. If <code>factory</code> is None, this function will look for an <code>produce</code> method on item.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def finalize(\nitem: Any,\nparameters: base.GenericDict | None = None,\nfactory: type[base.Factory] | None = None) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a factory that may need to be altered before being\n            returned by the factory `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        factory: the constructor used to create `item`. This need not be passed\n            if `item` is also the factory for its creation. Defaults to `None`.\n            If `factory` is None, this function will look for an `produce`\n            method on item.\n    Returns:\n        Modified item.\n    \"\"\"\nfactory = factory or item\nif (hasattr(factory, 'produce') and inspect.ismethod(factory.produce)):\nreturn factory.produce(item, parameters)\nelse:\nreturn item if parameters is None else item(**parameters)\n</code></pre>"},{"location":"reference/wonka/#wonka.inject_attributes","title":"<code>inject_attributes(item, parameters=None, overwrite=None)</code>","text":"<p>Manages <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to have <code>parameters</code> injected.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to add to <code>item</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>whether to overwrite existing attributes, if they exist. Defaults to <code>None</code>. If the value is <code>None</code>, the global <code>_OVERWRITE</code> setting will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def inject_attributes(\nitem: Any,\nparameters: base.GenericDict | None = None,\noverwrite: bool | None = None) -&gt; Any:\n\"\"\"Manages `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to have `parameters` injected.\n        parameters: keyword arguments to add to `item`. Defaults to `None`.\n        overwrite (Optional[bool]): whether to overwrite existing attributes,\n            if they exist. Defaults to `None`. If the value is `None`, the\n            global `_OVERWRITE` setting will be used.\n    Returns:\n        Modified item.\n    \"\"\"\nif parameters:\noverwrite = options._OVERWRITE if overwrite is None else overwrite\nfor key, value in parameters.items():\nif overwrite or not hasattr(item, key):\nsetattr(item, key, value)\nreturn item\n</code></pre>"},{"location":"reference/wonka/#wonka.is_constructor","title":"<code>is_constructor(item)</code>","text":"<p>Returns if <code>item</code> is a wonka-compatible constructor.</p> <p>If the global <code>_STRICT_COMPATIBILITY</code> setting is <code>True</code>, this function uses narrow definition of <code>constructor</code> to only include:     1) subclasses or instances of <code>Factory</code>; or     2) subclasss instances of <code>Manager</code>. If <code>_STRICT_COMPATIBILITY</code> is <code>False</code>, the function merely tests whether <code>item</code> has a <code>create</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a wonka-compatible constructor</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def is_constructor(item: Any) -&gt; bool:\n\"\"\"Returns if `item` is a wonka-compatible constructor.\n    If the global `_STRICT_COMPATIBILITY` setting is `True`, this function uses\n    narrow definition of `constructor` to only include:\n        1) subclasses or instances of `Factory`; or\n        2) subclasss instances of `Manager`.\n    If `_STRICT_COMPATIBILITY` is `False`, the function merely tests whether\n    `item` has a `create` method.\n    Args:\n        item: item to test.\n    Returns:\n        Whether `item` is a wonka-compatible constructor\n    \"\"\"\nif options._STRICT_COMPATIBILITY:\nreturn (\n(inspect.isclass(item) and issubclass(item, base.Factory))\nor isinstance(item, base.Manager | base.Factory))\nelse:\nreturn (\nhasattr(item, 'create')\nand inspect.ismethod(item.create))\n</code></pre>"},{"location":"reference/wonka/#wonka.set_compatibility_rule","title":"<code>set_compatibility_rule(compatibility)</code>","text":"<p>Sets the global attribute compatibility rule.</p> <p>Parameters:</p> Name Type Description Default <code>compatibility</code> <code>bool</code> <p>whether to require the <code>is_constructor</code> method to use strict or relaxed validation.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>compatibility</code> is not <code>bool</code>.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_compatibility_rule(compatibility: bool) -&gt; None:\n\"\"\"Sets the global attribute compatibility rule.\n    Args:\n        compatibility: whether to require the `is_constructor` method to use\n            strict or relaxed validation.\n    Raises:\n        TypeError: if `compatibility` is not `bool`.\n    \"\"\"\nif isinstance(compatibility, bool):\nglobals()[\"_STRICT_COMPATIBILITY\"] = compatibility\nelse:\nraise TypeError('compatibility argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/#wonka.set_keyer","title":"<code>set_keyer(keyer)</code>","text":"<p>Sets the global default function used to name <code>dict</code> keys.</p> <p>Parameters:</p> Name Type Description Default <code>keyer</code> <code>Callable[[object | type[Any]], str]</code> <p>function that returns a <code>str</code> name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>keyer</code> is not callable.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_keyer(keyer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name `dict` keys.\n    Args:\n        keyer: function that returns a `str` name of any item passed.\n    Raises:\n        TypeError: if `keyer` is not callable.\n    \"\"\"\nif isinstance(keyer, Callable):\nglobals()[\"_KEY_NAMER\"] = keyer\nelse:\nraise TypeError('keyer argument must be a callable')\n</code></pre>"},{"location":"reference/wonka/#wonka.set_method_namer","title":"<code>set_method_namer(namer)</code>","text":"<p>Sets the global default function used to name factory creation methods.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | type[Any]], str]</code> <p>function that returns a <code>str</code> name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'keyer' is not callable.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_method_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name factory creation methods.\n    Args:\n        namer: function that returns a `str` name of any item passed.\n    Raises:\n        TypeError: if 'keyer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()[\"_METHOD_NAMER\"] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/wonka/#wonka.set_overwrite_rule","title":"<code>set_overwrite_rule(overwrite)</code>","text":"<p>Sets the global attribute overwrite rule.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>whether to set the default rule to overwrite existing attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>overwrite</code> is not bool.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_overwrite_rule(overwrite: bool) -&gt; None:\n\"\"\"Sets the global attribute overwrite rule.\n    Args:\n        overwrite: whether to set the default rule to overwrite existing\n            attributes.\n    Raises:\n        TypeError: if `overwrite` is not bool.\n    \"\"\"\nif isinstance(overwrite, bool):\nglobals()[\"_OVERWRITE\"] = overwrite\nelse:\nraise TypeError('overwrite argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/#wonka.set_verbose_rule","title":"<code>set_verbose_rule(verbose)</code>","text":"<p>Sets the global attribute message verbosity rule.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>whether to set the default rule to verbosity in logging and messaging.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>verbose</code> is not bool.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_verbose_rule(verbose: bool) -&gt; None:\n\"\"\"Sets the global attribute message verbosity rule.\n    Args:\n        verbose: whether to set the default rule to verbosity in logging and\n            messaging.\n    Raises:\n        TypeError: if `verbose` is not bool.\n    \"\"\"\nif isinstance(verbose, bool):\nglobals()[\"_VERBOSE\"] = verbose\nelse:\nraise TypeError('verbose argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":"<p>Base classes for <code>wonka</code>.</p> Contents <p>Factory (<code>abc.ABC</code>): interface for basic <code>wonka</code> creation classes. A     <code>create</code> class method is required for subclasses. Manager (<code>Iterable</code>, <code>abc.ABC</code>): iterable interface for complex construction     managers. A <code>manage</code> instance method is required for subclasses. For     compatibility as a <code>wonka</code> constructor, a <code>create</code> property is included     which automatically calls the <code>manage</code> method with all args and kwargs. Producer (<code>abc.ABC</code>): mixin interface for classes that alter created items     before returning them. A <code>produce</code> class method is required for     subclasses. Constructor (<code>TypeAlias</code>): type alias for a wonka-compatible constructor     type. By default, it includes a <code>Factory</code> subclass, a <code>Factory</code> subclass     instance, and a <code>Manager</code> subclass instance.</p>"},{"location":"reference/wonka/base/#wonka.base.Cluster","title":"<code>Cluster</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base for collections of factories.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>ConstructorDict</code> <p>stored <code>dict</code> of <code>wonka</code> factories. Defaults to an empty <code>dict</code>.</p> <code>field(default_factory=dict)</code>"},{"location":"reference/wonka/base/#wonka.base.Cluster.contents","title":"<code>contents: ConstructorDict = dataclasses.field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Required Subclass Methods</p>"},{"location":"reference/wonka/base/#wonka.base.Cluster.add","title":"<code>add(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Adds <code>item</code> to the <code>contents</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ConstructorDict | Constructor</code> <p>factory or factories to add.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> Source code in <code>src/wonka/base.py</code> <pre><code>@abc.abstractmethod\ndef add(\nself,\nitem: ConstructorDict | Constructor,\n**kwargs: Kwargs) -&gt; None:\n\"\"\"Adds `item` to the `contents` attribute.\n    Args:\n        item: factory or factories to add.\n        kwargs: allows subclass to take other keyword arguments.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Cluster.delete","title":"<code>delete(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Deletes <code>item</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>key in <code>contents</code> to delete the key/value pair.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> Source code in <code>src/wonka/base.py</code> <pre><code>@abc.abstractmethod\ndef delete(self, item: str, **kwargs: Kwargs) -&gt; None:\n\"\"\"Deletes `item` in `contents`.\n    Args:\n        item: key in `contents` to delete the key/value pair.\n        kwargs: allows subclass to take other keyword arguments.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Factory","title":"<code>Factory</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base for <code>wonka</code> constructors.</p> <p>A <code>wonka</code> <code>Factory</code> can be subclassed into any constructer design (not just those that fit the classical factory design pattern). So, for example, the <code>wonka</code> package itself includes <code>Factory</code> subclasses that fit the prototype (<code>Scribe</code>), registry (<code>Registar</code> and<code>Subclasser</code>), and traditional factory (<code>Delegate</code> and <code>Sourcerer</code>) design patterns. Further, a <code>Manager</code> class instance may act as the director in a builder design pattern.</p> <p>One of the goals of <code>wonka</code>, though, is not be be wedded to or worried about the underlying design pattern. Instead, all constructers follow the simple, universal, and easily extensible interface of <code>Factory</code>.</p> <p>If you want to add code that modifies output of a <code>Factory</code>'s <code>create</code> class method, you can either include that in the subclass <code>create</code> method or by mixing in a <code>Producer</code> class. Details on how to use <code>Producer</code> subclasses are included in its documentation.</p>"},{"location":"reference/wonka/base/#wonka.base.Factory.create","title":"<code>create(item, **kwargs)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns a created or modified item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for creation of an item or an item to be modified.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef create(cls, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Returns a created or modified item.\n    Args:\n        item: data for creation of an item or an item to be modified.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Created item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Manager","title":"<code>Manager</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Iterable</code>, <code>ABC</code></p> <p>Base for manageing complex class or object construction.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Iterable</code> <p>an iterable containing <code>Factory</code> subclasses or <code>Manager</code> subclass instances.</p> required"},{"location":"reference/wonka/base/#wonka.base.Manager.contents","title":"<code>contents: Iterable</code>  <code>instance-attribute</code>","text":"<p>Required Subclass Methods</p>"},{"location":"reference/wonka/base/#wonka.base.Manager.create","title":"<code>create(item, **kwargs)</code>","text":"<p>Calls <code>manage</code> method.</p> <p>This method is included as a convenience so that an instance of a <code>Manager</code> can be used as a drop-in for a <code>Factory</code> subclass. <code>Manager</code> cannot easily be made a subclass for <code>Factory</code> because it will often need to rely on instance data for construction. So, every <code>Manager</code> subclass should be designed such that an instance of that subclass could be substituted for a <code>Factory</code> subclass. This allows other <code>Manager</code> subclass instances to be stored in <code>contents</code> as part of an iterable workflow.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to factories in <code>contents</code>.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>def create(self, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Calls `manage` method.\n    This method is included as a convenience so that an instance of a\n    `Manager` can be used as a drop-in for a `Factory` subclass. `Manager`\n    cannot easily be made a subclass for `Factory` because it will often\n    need to rely on instance data for construction. So, every `Manager`\n    subclass should be designed such that an instance of that subclass could\n    be substituted for a `Factory` subclass. This allows other `Manager`\n    subclass instances to be stored in `contents` as part of an iterable\n    workflow.\n    Args:\n        item: item to be passed to factories in `contents`.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Constructed item.\n    \"\"\"\nreturn self.manage(item, **kwargs)\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Manager.manage","title":"<code>manage(item, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Manages construction and/or modification based on <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to factories in <code>contents</code>.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take other keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@abc.abstractmethod\ndef manage(self, item: Any, **kwargs: Kwargs) -&gt; Any:\n\"\"\"Manages construction and/or modification based on `item`.\n    Args:\n        item: item to be passed to factories in `contents`.\n        kwargs: allows subclass to take other keyword arguments.\n    Returns:\n        Constructed item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Producer","title":"<code>Producer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base mixin for modifying items.</p> <p>A <code>Producer</code>'s <code>produce</code> method will automatically be called if it is mixed-in with any of the <code>Factory</code> classes in <code>wonka</code>. If you want a custom <code>Factory</code> subclass to similarly automatically check for a <code>produce</code> method, the easiest way to do that is to simply call the <code>finalize</code> function as your return value for the <code>Factory</code>'s <code>create</code> method as follows:</p> <pre><code>return wonka.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/base/#wonka.base.Producer.produce","title":"<code>produce(item, parameters=None)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/wonka/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef produce(\ncls,\nitem: Any,\nparameters: GenericDict | None = None) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to be modified.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n    Returns:\n        Any: modified item.\n    \"\"\"\n</code></pre>"},{"location":"reference/wonka/clusters/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> clusters","text":"<p>Stores groups of <code>wonka</code> constructors.</p> Contents <p>Manufacturer: <code>dict</code>-like class that stores <code>wonka</code> constructors. Has an     <code>add</code> method that validates any added values as <code>wonka</code> compatible.</p>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer","title":"<code>Manufacturer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Cluster</code></p> <p><code>dict</code>-like container of factories.</p> <p>A <code>Manufacturer</code> may serve as a one-stop spot for factories. Each factory need not be of the same subtype, as they pass the <code>is_constructor</code> test. The use of a <code>Manufacturer</code> is wholly optional - it is just a convenience offered by <code>wonka</code>. To access individual constructors, the following format should be used:</p> <pre><code>manufacturer_instance['constructor_name'].create(*args, **kwargs)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>ConstructorDict</code> <p>stored <code>dict</code> of <code>wonka</code> factories. Defaults to an empty <code>dict</code>.</p> <code>field(default_factory=dict)</code>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.contents","title":"<code>contents: base.ConstructorDict = dataclasses.field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.add","title":"<code>add(item)</code>","text":"<p>Adds <code>item</code> to the <code>contents</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>ConstructorDict | Constructor</code> <p>factory or factories to add.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if all of the values of <code>item</code> are not <code>wonka</code>-compatible factories or if <code>item</code> itself is not a <code>wonka</code>-compatible factory.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def add(self, item: base.ConstructorDict | base.Constructor) -&gt; None:\n\"\"\"Adds `item` to the `contents` attribute.\n    Args:\n        item: factory or factories to add.\n    Raises:\n        TypeError: if all of the values of `item` are not `wonka`-compatible\n            factories or if `item` itself is not a `wonka`-compatible\n            factory.\n    \"\"\"\nif isinstance(item, MutableMapping):\nif all(shared.is_constructor(v) for v in item.values()):\nself.contents.update(item)\nelse:\nmessage = (\n'All values in item must be wonka-compatible constructors')\nraise TypeError(message)\nelif shared.is_constructor(item):\nkey = options._KEY_NAMER(item)\nself.contents.update({key: item})\nelse:\nmessage = (\n'item must either be a wonka-compatible constructor or a dict-'\n'like object with values that are constructors')\nraise TypeError(message)\n</code></pre>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.delete","title":"<code>delete(item)</code>","text":"<p>Deletes <code>item</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in <code>contents</code> to delete the key/value pair.</p> required Source code in <code>src/wonka/clusters.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes `item` in `contents`.\n    Args:\n        item: key in `contents` to delete the key/value pair.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.items","title":"<code>items()</code>","text":"<p>Emulates Python <code>dict</code> <code>items</code> method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>A <code>tuple</code> equivalent to <code>dict.items()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates Python `dict` `items` method.\n    Returns:\n        A `tuple` equivalent to `dict.items()`.\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values(), strict = True))\n</code></pre>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.keys","title":"<code>keys()</code>","text":"<p>Returns <code>contents</code> keys as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>A <code>tuple</code> equivalent to <code>dict.keys()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns `contents` keys as a `tuple`.\n    Returns:\n        A `tuple` equivalent to `dict.keys()`.\n    \"\"\"\nreturn tuple(self.contents.keys())\n</code></pre>"},{"location":"reference/wonka/clusters/#wonka.clusters.Manufacturer.values","title":"<code>values()</code>","text":"<p>Returns <code>contents</code> values as a <code>tuple</code>.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>A tuple equivalent to <code>dict.values()</code>.</p> Source code in <code>src/wonka/clusters.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns `contents` values as a `tuple`.\n    Returns:\n        A tuple equivalent to `dict.values()`.\n    \"\"\"\nreturn tuple(self.contents.values())\n</code></pre>"},{"location":"reference/wonka/dispatchers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dispatchers","text":"<p>Dispatchers: factory classes that call other constructors.</p> Contents <p>Delegate (<code>base.Factory</code>): builds classes and/or instances using methods     that follow a naming convention and the <code>str</code> names of the types of the     first argument passed to the <code>create</code> class method. Sourcerer (<code>base.Factory</code>): builds classes and/or instances using methods     that follow a naming convention (set at <code>configuration._METHOD_NAMER</code>)     and a <code>dict</code> of types stored in the <code>sources</code> class attribute.</p>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers.Delegate","title":"<code>Delegate</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Builds based on the <code>str</code> name of the type passed.</p> <p>This factory acts as a dispatcher to call creation methods based on the type or name of the type passed in a manner identical to <code>Sourcerer</code>. However, unlike <code>Sourcerer</code>, <code>Delegate</code> only finds a matching creation method if the <code>str</code> name of the type of <code>item</code> matches a substring of the creation method name using the format of <code>configuration._METHOD_NAMER</code>.</p>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers.Delegate.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an appropriate method does not exist for the data type of <code>item.</code></p> <code>KeyError</code> <p>If a corresponding subclass does not exist for <code>item.</code></p> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to take kwargs.\n    Raises:\n        AttributeError: If an appropriate method does not exist for the\n            data type of `item.`\n        KeyError: If a corresponding subclass does not exist for `item.`\n    Returns:\n        Created item.\n    \"\"\"\nbuilder = _get_creation_method_name(item)\nitem = _get_from_builder_method(\nfactory = cls,\nmethod = builder,\nsource = item,\n**kwargs)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers.Sourcerer","title":"<code>Sourcerer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code>, <code>ABC</code></p> <p>Builds based on compatibility with keys in the <code>sources</code> class attribute.</p> <p>This factory acts as a dispatcher to call other methods based on the type passed. Unlike <code>Delegate</code>, <code>Sourcerer</code> is more forgiving by allowing the type passed to a subtype or instance of the type listed as a key in the <code>sources</code> class attribute.</p> <p>The name for a <code>Sourcerer</code> is spelled the way it is instead of \"Sorcerer\" because the <code>sources</code> attribute is used. This is inspired by the \"Divinity: Original Sin\" games where the magic users are called \"Sourcerers\" because they may manipulate the magical energy known as \"source\". https://divinity.fandom.com/wiki/Sourcerer</p> <p>Attributes:</p> Name Type Description <code>sources</code> <code>MutableMapping[type[Any], str]</code> <p><code>dict</code> with keys that are types and values are substrings of the names of methods to call when the key type is passed to the <code>create</code> method. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers.Sourcerer.sources","title":"<code>sources: MutableMapping[type[Any], str] = {}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers.Sourcerer.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to add additional parameters.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the value matching the key <code>item</code> does not correspond to a method in the <code>Sourcerer</code> subclass.</p> <code>KeyError</code> <p>if there is no key in <code>sources</code> matching the type for <code>item</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Created item.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to add additional parameters.\n    Raises:\n        AttributeError: if the value matching the key `item` does not\n            correspond to a method in the `Sourcerer` subclass.\n        KeyError: if there is no key in `sources` matching the type for\n            `item`.\n    Returns:\n        Created item.\n    \"\"\"\nfor kind, substring in cls.sources.items():\nif _is_kind(item, kind):\nbuilder = _get_creation_method_name(substring)\nitem = _get_from_builder_method(\nfactory = cls,\nmethod = builder,\nsource = item,\n**kwargs)\nreturn shared.finalize(item = item, parameters = parameters)\nraise KeyError(f'{item} does not match any recognized types')\n</code></pre>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers._get_creation_method_name","title":"<code>_get_creation_method_name(source, method_namer=None)</code>","text":"<p>Returns the creation method name for factories that call other methods.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>source data for creating a method name.</p> required <code>method_namer</code> <code>Callable[[object | type[Any]], str] | None</code> <p>callable to create the creation method name. Defaults to <code>None</code>.  If it is <code>None</code>, the global namer stored in <code>configuration._METHOD_NAMER</code> will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Name of the creation method to use.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>def _get_creation_method_name(\nsource: Any,\nmethod_namer: Callable[[object | type[Any]], str] | None = None) -&gt; str:\n\"\"\"Returns the creation method name for factories that call other methods.\n    Args:\n        source: source data for creating a method name.\n        method_namer: callable to create the creation method name. Defaults to\n            `None`.  If it is `None`, the global namer stored in\n            `configuration._METHOD_NAMER` will be used.\n    Returns:\n        Name of the creation method to use.\n    \"\"\"\nif not isinstance(source, str):\nsource = options._KEY_NAMER(source)\nnamer = method_namer or options._METHOD_NAMER\nreturn namer(source)\n</code></pre>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers._get_from_builder_method","title":"<code>_get_from_builder_method(factory, method, source, **kwargs)</code>","text":"<p>Returns constructed item from a builder method of <code>factory</code>.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>Any</code> <p>factory class or instance.</p> required <code>method</code> <p>name of the method to use to construct an item.</p> required <code>source</code> <code>Any</code> <p>the <code>source</code> data used to create item.</p> required <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if <code>factory</code> has no method named <code>method</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>def _get_from_builder_method(\nfactory: Any,\nmethod: str,\nsource: Any,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Returns constructed item from a builder method of `factory`.\n    Args:\n        factory: factory class or instance.\n        method : name of the method to use to construct an item.\n        source: the `source` data used to create item.\n        kwargs: allows subclass to take kwargs.\n    Raises:\n        AttributeError: if `factory` has no method named `method`.\n    Returns:\n        Constructed item.\n    \"\"\"\ntry:\nbuilder = getattr(factory, method)\nreturn builder(source, **kwargs)\nexcept AttributeError as e:\nraise AttributeError(f'{method} does not exist in {factory}') from e\n</code></pre>"},{"location":"reference/wonka/dispatchers/#wonka.dispatchers._is_kind","title":"<code>_is_kind(item, kind)</code>","text":"<p>Returns if <code>item</code> is an instance or subclass of <code>kind</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to evalute.</p> required <code>kind</code> <code>type[Any]</code> <p>type to compare <code>item</code> to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is an instance or subclass of <code>kind</code>.</p> Source code in <code>src/wonka/dispatchers.py</code> <pre><code>def _is_kind(item: Any, kind: type[Any]) -&gt; bool:\n\"\"\"Returns if `item` is an instance or subclass of `kind`.\n    Args:\n        item (Any): item to evalute.\n        kind (type[Any]): type to compare `item` to.\n    Returns:\n        Whether `item` is an instance or subclass of `kind`.\n    \"\"\"\nreturn (\nisinstance(item, kind)\nor (inspect.isclass(item and issubclass(item, kind))))\n</code></pre>"},{"location":"reference/wonka/managers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> managers","text":"<p>Manager classes for iterable constructors.</p> Contents <p>Assembler (<code>MutableSequence</code>, <code>base.Manager</code>): iterable that stores a list     of constructors that build an item like an assembly line.</p>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler","title":"<code>Assembler</code>  <code>dataclass</code>","text":"<p>             Bases: <code>MutableSequence</code>, <code>Manager</code></p> <p>Assembly line constructer.</p> <p>Assembler stores a sequence of wonka constructors that are called by the <code>manage</code> (or <code>create</code>) method in order to construct an item.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Constructor]</code> <p>stored constructors. Defaults to an empty list.</p> <code>field(default_factory=list)</code>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.contents","title":"<code>contents: MutableSequence[base.Constructor] = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.add","title":"<code>add(item)</code>","text":"<p>Adds <code>item</code> to the <code>contents</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Constructor | Sequence[Constructor]</code> <p>item(s) to add to <code>contents</code> attribute.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if all of the values of <code>item</code> are not wonka-compatible constructors.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def add(self, item: base.Constructor | Sequence[base.Constructor]) -&gt; None:\n\"\"\"Adds `item` to the `contents` attribute.\n    Args:\n        item: item(s) to add to `contents` attribute.\n    Raises:\n        TypeError: if all of the values of `item` are not wonka-compatible\n            constructors.\n    \"\"\"\nif shared.is_constructor(item):\nself.contents.append(item)\nelif (isinstance(item, Sequence)\nand all(shared.is_constructor(v) for v in item)):\nself.contents.extend(item)\nelse:\nraise TypeError(\n'All values in item must be wonka-compatible constructors')\n</code></pre>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.delete","title":"<code>delete(item)</code>","text":"<p>Deletes item at the index in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>index in <code>contents</code> to delete.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def delete(self, item: int) -&gt; None:\n\"\"\"Deletes item at the index in `contents`.\n    Args:\n        item: index in `contents` to delete.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.insert","title":"<code>insert(index, item)</code>","text":"<p>Inserts <code>item</code> at <code>index</code> in <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index to insert <code>item</code> at.</p> required <code>item</code> <code>Any</code> <p>object to be inserted.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def insert(self, index: int, item: Any) -&gt; None:\n\"\"\"Inserts `item` at `index` in `contents`.\n    Args:\n        index: index to insert `item` at.\n        item: object to be inserted.\n    \"\"\"\nself.contents.insert(index, item)\nreturn\n</code></pre>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.manage","title":"<code>manage(item)</code>","text":"<p>Manages construction and/or modification based on <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be passed to constructors in <code>contents</code>.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Constructed item.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def manage(self, item: Any) -&gt; Any:\n\"\"\"Manages construction and/or modification based on `item`.\n    Args:\n        item: item to be passed to constructors in `contents`.\n    Returns:\n        Constructed item.\n    \"\"\"\nfor constructor in self.contents:\nitem = constructor.create(item)\nreturn item\n</code></pre>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends <code>item</code> to <code>contents</code>.</p> <p>If <code>item</code> is a non-<code>str</code> sequence, <code>prepend</code> adds its contents to the stored list in the order they appear in <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to prepend to <code>contents</code>.</p> required Source code in <code>src/wonka/managers.py</code> <pre><code>def prepend(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Prepends `item` to `contents`.\n    If `item` is a non-`str` sequence, `prepend` adds its contents to the\n    stored list in the order they appear in `item`.\n    Args:\n        item: item(s) to prepend to `contents`.\n    \"\"\"\nif utilities._is_sequence(item = item):\nfor thing in reversed(item):\nself.prepend(item = thing)\nelse:\nself.insert(0, item)\nreturn\n</code></pre>"},{"location":"reference/wonka/managers/#wonka.managers.Assembler.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of <code>contents</code>.</p> <p>This method applies <code>include</code> before <code>exclude</code> if both are passed. If <code>include</code> is None, all existing items will be added to the new subset class instance before <code>exclude</code> is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Any | Sequence[Any] | None</code> <p>item(s) to include in the new instance. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Any | Sequence[Any] | None</code> <p>item(s) to exclude in the new instance. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>include</code> and <code>exclude</code> are both None.</p> <p>Returns:</p> Type Description <code>Assembler</code> <p>Assembler with only items from <code>include</code> and no items in <code>exclude</code>.</p> Source code in <code>src/wonka/managers.py</code> <pre><code>def subset(\nself,\ninclude: Any | Sequence[Any] | None = None,\nexclude: Any | Sequence[Any] | None = None) -&gt; Assembler:\n\"\"\"Returns a new instance with a subset of `contents`.\n    This method applies `include` before `exclude` if both are passed. If\n    `include` is None, all existing items will be added to the new subset\n    class instance before `exclude` is applied.\n    Args:\n        include: item(s) to include in the new instance. Defaults to None.\n        exclude: item(s) to exclude in the new instance. Defaults to None.\n    Raises:\n        ValueError: if `include` and `exclude` are both None.\n    Returns:\n        Assembler with only items from `include` and no items in `exclude`.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(utilities._iterify(include))\ncontents = [i for i in self.contents if i in include]\nif exclude is not None:\nexclude = list(utilities._iterify(exclude))\ncontents = [i for i in contents if i not in exclude]\nnew_listing = copy.deepcopy(self)\nnew_listing.contents = contents\nreturn new_listing\n</code></pre>"},{"location":"reference/wonka/options/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> options","text":"<p>Configuration settings and convenience functions for changing those settings.</p> Contents <p>set_compatibility_rule: sets the global attribute compatibility rule. set_keyer: sets the global default function used to name dict keys. set_method_namer: sets the global default function used to name factory     creation methods. set_overwrite_rule: sets the global attribute overwrite rule. set_verbose_rule: sets the global attribute message verbosity rule.</p>"},{"location":"reference/wonka/options/#wonka.options.set_compatibility_rule","title":"<code>set_compatibility_rule(compatibility)</code>","text":"<p>Sets the global attribute compatibility rule.</p> <p>Parameters:</p> Name Type Description Default <code>compatibility</code> <code>bool</code> <p>whether to require the <code>is_constructor</code> method to use strict or relaxed validation.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>compatibility</code> is not <code>bool</code>.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_compatibility_rule(compatibility: bool) -&gt; None:\n\"\"\"Sets the global attribute compatibility rule.\n    Args:\n        compatibility: whether to require the `is_constructor` method to use\n            strict or relaxed validation.\n    Raises:\n        TypeError: if `compatibility` is not `bool`.\n    \"\"\"\nif isinstance(compatibility, bool):\nglobals()[\"_STRICT_COMPATIBILITY\"] = compatibility\nelse:\nraise TypeError('compatibility argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/options/#wonka.options.set_keyer","title":"<code>set_keyer(keyer)</code>","text":"<p>Sets the global default function used to name <code>dict</code> keys.</p> <p>Parameters:</p> Name Type Description Default <code>keyer</code> <code>Callable[[object | type[Any]], str]</code> <p>function that returns a <code>str</code> name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>keyer</code> is not callable.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_keyer(keyer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name `dict` keys.\n    Args:\n        keyer: function that returns a `str` name of any item passed.\n    Raises:\n        TypeError: if `keyer` is not callable.\n    \"\"\"\nif isinstance(keyer, Callable):\nglobals()[\"_KEY_NAMER\"] = keyer\nelse:\nraise TypeError('keyer argument must be a callable')\n</code></pre>"},{"location":"reference/wonka/options/#wonka.options.set_method_namer","title":"<code>set_method_namer(namer)</code>","text":"<p>Sets the global default function used to name factory creation methods.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | type[Any]], str]</code> <p>function that returns a <code>str</code> name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'keyer' is not callable.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_method_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name factory creation methods.\n    Args:\n        namer: function that returns a `str` name of any item passed.\n    Raises:\n        TypeError: if 'keyer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()[\"_METHOD_NAMER\"] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/wonka/options/#wonka.options.set_overwrite_rule","title":"<code>set_overwrite_rule(overwrite)</code>","text":"<p>Sets the global attribute overwrite rule.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>whether to set the default rule to overwrite existing attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>overwrite</code> is not bool.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_overwrite_rule(overwrite: bool) -&gt; None:\n\"\"\"Sets the global attribute overwrite rule.\n    Args:\n        overwrite: whether to set the default rule to overwrite existing\n            attributes.\n    Raises:\n        TypeError: if `overwrite` is not bool.\n    \"\"\"\nif isinstance(overwrite, bool):\nglobals()[\"_OVERWRITE\"] = overwrite\nelse:\nraise TypeError('overwrite argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/options/#wonka.options.set_verbose_rule","title":"<code>set_verbose_rule(verbose)</code>","text":"<p>Sets the global attribute message verbosity rule.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>whether to set the default rule to verbosity in logging and messaging.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>verbose</code> is not bool.</p> Source code in <code>src/wonka/options.py</code> <pre><code>def set_verbose_rule(verbose: bool) -&gt; None:\n\"\"\"Sets the global attribute message verbosity rule.\n    Args:\n        verbose: whether to set the default rule to verbosity in logging and\n            messaging.\n    Raises:\n        TypeError: if `verbose` is not bool.\n    \"\"\"\nif isinstance(verbose, bool):\nglobals()[\"_VERBOSE\"] = verbose\nelse:\nraise TypeError('verbose argument must be boolean')\n</code></pre>"},{"location":"reference/wonka/producers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> producers","text":"<p>Mixins for created object modification.</p> Contents <p>Classer (<code>base.Producer</code>, <code>abc.ABC</code>): Producer with an <code>produce</code> method that     always returns a class. Flexer (<code>base.Producer</code>, <code>abc.ABC</code>): Producer that conditions return value     of the <code>produce</code> method based on whether <code>parameters</code> are passed. Instancer (<code>base.Producer</code>, <code>abc.ABC</code>): Producer with an <code>produce</code> method     that always returns an instance.</p>"},{"location":"reference/wonka/producers/#wonka.producers.Classer","title":"<code>Classer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer with an <code>produce</code> method always return a class.</p>"},{"location":"reference/wonka/producers/#wonka.producers.Classer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>. The argument for <code>parameters</code> is ignored by <code>Classer</code> - it is only included to provide a consistent interface across all <code>Producer</code> subclasses.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`. The argument for `parameters` is ignored by\n            `Classer` - it is only included to provide a consistent\n            interface across all `Producer` subclasses.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nreturn item if inspect.isclass(item) else item.__class__\n</code></pre>"},{"location":"reference/wonka/producers/#wonka.producers.Flexer","title":"<code>Flexer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer that conditions return value of the <code>produce</code> method.</p> <p>If <code>parameters</code> are passed to the <code>produce</code> method, an instance is always returned. If no <code>parameters</code> are passed, the item will be returned as-is (depending on the constructor used).</p>"},{"location":"reference/wonka/producers/#wonka.producers.Flexer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nif parameters is None:\nreturn item\nelif inspect.isclass(item):\nreturn item(**parameters)\nelse:\nreturn shared.inject_attributes(item, parameters)\n</code></pre>"},{"location":"reference/wonka/producers/#wonka.producers.Instancer","title":"<code>Instancer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Producer</code>, <code>ABC</code></p> <p>Producer with an <code>produce</code> method always return an instance.</p>"},{"location":"reference/wonka/producers/#wonka.producers.Instancer.produce","title":"<code>produce(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Modifies <code>item</code> and incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a constructor that may need to be altered before being returned by the constructor <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/producers.py</code> <pre><code>@classmethod\ndef produce(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Modifies `item` and incorporates `parameters`.\n    Args:\n        item: item created by a constructor that may need to be altered\n            before being returned by the constructor `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Modified item.\n    \"\"\"\nif inspect.isclass(item) and parameters is None:\nreturn item()\nelif parameters is None:\nreturn item\nelif inspect.isclass(item):\nreturn item(**parameters)\nelse:\nreturn shared.inject_attributes(item, parameters)\n</code></pre>"},{"location":"reference/wonka/prototypers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> prototypers","text":"<p>Factory classes that clone items.</p> Contents <p>Scribe (<code>base.Factory</code>): factory that clones a passed argument or, if none     is passed, itself.</p>"},{"location":"reference/wonka/prototypers/#wonka.prototypers.Scribe","title":"<code>Scribe</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Base class for cloning classes or objects.</p>"},{"location":"reference/wonka/prototypers/#wonka.prototypers.Scribe.create","title":"<code>create(item=None, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Clones <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | None</code> <p>item to clone. If it is None, the <code>create</code> method assumes that it should clone itself. Defaults to None.</p> <code>None</code> <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Cloned item.</p> Source code in <code>src/wonka/prototypers.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any | None = None,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Clones `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to clone. If it is None, the `create` method assumes that\n            it should clone itself. Defaults to None.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        kwargs: allows subclass to take kwargs.\n    Returns:\n        Cloned item.\n    \"\"\"\nitem = item or cls\nitem = copy.deepcopy(item)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/registries/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> registries","text":"<p>Factory classes that utilize explicit or implicit registries.</p> Contents <p>Registrar (<code>base.Factory</code>): builds classes and/or instances from a registry     stored in the <code>registry</code> class attribute. Subclasser (base.Factory, abc.ABC): builds classes and/or instances from the     <code>__subclasses__</code> method and a dynamically created registry based upon     it.</p>"},{"location":"reference/wonka/registries/#wonka.registries.Registrar","title":"<code>Registrar</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code></p> <p>Builds an item from a registry.</p> <p>Attributes:</p> Name Type Description <code>registry</code> <code>GenericDict</code> <p>stores classes and/or instances to be used in item construction. Defaults to an empty <code>dict</code>.</p>"},{"location":"reference/wonka/registries/#wonka.registries.Registrar.registry","title":"<code>registry: base.GenericDict = {}</code>  <code>class-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/wonka/registries/#wonka.registries.Registrar.create","title":"<code>create(item, parameters=None)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>name corresponding to a key in <code>registry</code>.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a corresponding item in <code>registry</code> does not exist for <code>item.</code></p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>created item.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: str,\nparameters: base.GenericDict | None = None) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    Args:\n        item (Hashable): name corresponding to a key in `registry`.\n        parameters: keyword arguments to pass or add to a created instance.\n    Raises:\n        KeyError: If a corresponding item in `registry` does not exist for\n            `item.`\n    Returns:\n        Any: created item.\n    \"\"\"\nitem = _get_from_registry(item = item, registry = cls.registry)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/registries/#wonka.registries.Subclasser","title":"<code>Subclasser</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Factory</code>, <code>ABC</code></p> <p>Builds a subclass without requiring a storage attribute.</p> <p>Unlike some other factories, this one does not require any class attributes. Instead, it relies on pre-existing data and lazily adds keys to create a registry facade.</p> <p>This factory uses the subclasses stored in <code>__subclasses__</code> class method that is automatically created with every class. It creates a <code>dict</code> on the fly with key names based on <code>configuration._KEY_NAMER</code>. Because of this, <code>Subclasser</code> should ordinarily be used as a mixin (although it could simply be subclassed, if you prefer).</p>"},{"location":"reference/wonka/registries/#wonka.registries.Subclasser.create","title":"<code>create(item, parameters=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an item based on <code>item</code> and possibly <code>parameters</code>.</p> <p>A subclass in the <code>__subclasses__</code> class method is selected based on the naming convention in <code>wonka._KEY_NAMER</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>data for construction of the returned item.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance.</p> <code>None</code> <code>kwargs</code> <code>Kwargs</code> <p>allows subclass to take kwargs.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a corresponding subclass does not exist for <code>item.</code></p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>created item.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>@classmethod\ndef create(\ncls,\nitem: Any,\nparameters: base.GenericDict | None = None,\n**kwargs: base.Kwargs) -&gt; Any:\n\"\"\"Creates an item based on `item` and possibly `parameters`.\n    A subclass in the `__subclasses__` class method is selected based on the\n    naming convention in `wonka._KEY_NAMER`.\n    Args:\n        item: data for construction of the returned item.\n        parameters: keyword arguments to pass or add to a created instance.\n        kwargs: allows subclass to take kwargs.\n    Raises:\n        KeyError: If a corresponding subclass does not exist for `item.`\n    Returns:\n        Any: created item.\n    \"\"\"\nkeyer = options._KEY_NAMER\nall_subclasses = _get_all_subclasses(cls)\nregistry = {keyer(s): s for s in all_subclasses}\nitem = _get_from_registry(item = item, registry = registry)\nreturn shared.finalize(item = item, parameters = parameters)\n</code></pre>"},{"location":"reference/wonka/registries/#wonka.registries._get_all_subclasses","title":"<code>_get_all_subclasses(item)</code>","text":"<p>Returns a list of all subclasses of <code>items</code>, including indirect ones.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[Any]</code> <p>class for which to find subclasses.</p> required <p>Returns:</p> Type Description <code>list[type[Any]]</code> <p>List of all subclasses of <code>item</code>.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>def _get_all_subclasses(item: type[Any]) -&gt; list[type[Any]]:\n\"\"\"Returns a list of all subclasses of `items`, including indirect ones.\n    Args:\n        item: class for which to find subclasses.\n    Returns:\n        List of all subclasses of `item`.\n    \"\"\"\nreturn list(set(item.__subclasses__()).union(\n[s for c in item.__subclasses__() for s in _get_all_subclasses(c)]))\n</code></pre>"},{"location":"reference/wonka/registries/#wonka.registries._get_from_registry","title":"<code>_get_from_registry(item, registry)</code>","text":"<p>Returns a copy of a stored item in <code>registry</code> with the key of <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key for item sought in <code>registry</code>.</p> required <code>registry</code> <code>GenericDict</code> <p>registry where the sought item is stored.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>item</code> does not match any key in <code>registry</code>.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>a deep copy of an item stored in <code>registry</code>.</p> Source code in <code>src/wonka/registries.py</code> <pre><code>def _get_from_registry(item: str, registry: base.GenericDict) -&gt; Any:\n\"\"\"Returns a copy of a stored item in `registry` with the key of `item`.\n    Args:\n        item (Hashable): key for item sought in `registry`.\n        registry: registry where the sought item is stored.\n    Raises:\n        KeyError: if `item` does not match any key in `registry`.\n    Returns:\n        Any: a deep copy of an item stored in `registry`.\n    \"\"\"\ntry:\nreturn copy.deepcopy(registry[item])\nexcept KeyError as e:\nraise KeyError(f'{item} was not found in the registry') from e\n</code></pre>"},{"location":"reference/wonka/shared/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> shared","text":"<p>Shared business logic functions for <code>wonka</code>.</p> Contents <p>finalize: finalizes construction before returning a value, including calling     the <code>produce</code> method of the passed item. inject_attributes: adds keys and values of a mapping to a class or instance     as attributes. is_constructor: returns <code>bool</code> as to whether an item is a <code>wonka</code>-compatible     constructor.</p>"},{"location":"reference/wonka/shared/#wonka.shared.finalize","title":"<code>finalize(item, parameters=None, factory=None)</code>","text":"<p>Modifies <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item created by a factory that may need to be altered before being returned by the factory <code>create</code> method.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to pass or add to a created instance. Defaults to <code>None</code>.</p> <code>None</code> <code>factory</code> <code>type[Factory] | None</code> <p>the constructor used to create <code>item</code>. This need not be passed if <code>item</code> is also the factory for its creation. Defaults to <code>None</code>. If <code>factory</code> is None, this function will look for an <code>produce</code> method on item.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def finalize(\nitem: Any,\nparameters: base.GenericDict | None = None,\nfactory: type[base.Factory] | None = None) -&gt; Any:\n\"\"\"Modifies `item` and possibly incorporates `parameters`.\n    Args:\n        item: item created by a factory that may need to be altered before being\n            returned by the factory `create` method.\n        parameters: keyword arguments to pass or add to a created instance.\n            Defaults to `None`.\n        factory: the constructor used to create `item`. This need not be passed\n            if `item` is also the factory for its creation. Defaults to `None`.\n            If `factory` is None, this function will look for an `produce`\n            method on item.\n    Returns:\n        Modified item.\n    \"\"\"\nfactory = factory or item\nif (hasattr(factory, 'produce') and inspect.ismethod(factory.produce)):\nreturn factory.produce(item, parameters)\nelse:\nreturn item if parameters is None else item(**parameters)\n</code></pre>"},{"location":"reference/wonka/shared/#wonka.shared.inject_attributes","title":"<code>inject_attributes(item, parameters=None, overwrite=None)</code>","text":"<p>Manages <code>item</code> and possibly incorporates <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to have <code>parameters</code> injected.</p> required <code>parameters</code> <code>GenericDict | None</code> <p>keyword arguments to add to <code>item</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>whether to overwrite existing attributes, if they exist. Defaults to <code>None</code>. If the value is <code>None</code>, the global <code>_OVERWRITE</code> setting will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def inject_attributes(\nitem: Any,\nparameters: base.GenericDict | None = None,\noverwrite: bool | None = None) -&gt; Any:\n\"\"\"Manages `item` and possibly incorporates `parameters`.\n    Args:\n        item: item to have `parameters` injected.\n        parameters: keyword arguments to add to `item`. Defaults to `None`.\n        overwrite (Optional[bool]): whether to overwrite existing attributes,\n            if they exist. Defaults to `None`. If the value is `None`, the\n            global `_OVERWRITE` setting will be used.\n    Returns:\n        Modified item.\n    \"\"\"\nif parameters:\noverwrite = options._OVERWRITE if overwrite is None else overwrite\nfor key, value in parameters.items():\nif overwrite or not hasattr(item, key):\nsetattr(item, key, value)\nreturn item\n</code></pre>"},{"location":"reference/wonka/shared/#wonka.shared.is_constructor","title":"<code>is_constructor(item)</code>","text":"<p>Returns if <code>item</code> is a wonka-compatible constructor.</p> <p>If the global <code>_STRICT_COMPATIBILITY</code> setting is <code>True</code>, this function uses narrow definition of <code>constructor</code> to only include:     1) subclasses or instances of <code>Factory</code>; or     2) subclasss instances of <code>Manager</code>. If <code>_STRICT_COMPATIBILITY</code> is <code>False</code>, the function merely tests whether <code>item</code> has a <code>create</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>item</code> is a wonka-compatible constructor</p> Source code in <code>src/wonka/shared.py</code> <pre><code>def is_constructor(item: Any) -&gt; bool:\n\"\"\"Returns if `item` is a wonka-compatible constructor.\n    If the global `_STRICT_COMPATIBILITY` setting is `True`, this function uses\n    narrow definition of `constructor` to only include:\n        1) subclasses or instances of `Factory`; or\n        2) subclasss instances of `Manager`.\n    If `_STRICT_COMPATIBILITY` is `False`, the function merely tests whether\n    `item` has a `create` method.\n    Args:\n        item: item to test.\n    Returns:\n        Whether `item` is a wonka-compatible constructor\n    \"\"\"\nif options._STRICT_COMPATIBILITY:\nreturn (\n(inspect.isclass(item) and issubclass(item, base.Factory))\nor isinstance(item, base.Manager | base.Factory))\nelse:\nreturn (\nhasattr(item, 'create')\nand inspect.ismethod(item.create))\n</code></pre>"},{"location":"reference/wonka/utilities/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utilities","text":"<p>Shared tools.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/wonka/utilities/#wonka.utilities._is_sequence","title":"<code>_is_sequence(item, *, include_str=False)</code>","text":"<p>Returns if <code>item</code> is a sequence.</p> <p>If <code>exclude_str</code> is True (the default) and <code>item</code> is a str, False will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to examine.</p> required <code>include_str</code> <code>bool</code> <p>whether to return True if <code>item</code> is a <code>str</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether an <code>item</code> is a sequence.</p> Source code in <code>src/wonka/utilities.py</code> <pre><code>def _is_sequence(\nitem: Any, *,\ninclude_str: bool = False) -&gt; bool:\n\"\"\"Returns if `item` is a sequence.\n    If `exclude_str` is True (the default) and `item` is a str, False will be\n    returned.\n    Args:\n        item: object to examine.\n        include_str: whether to return True if `item` is a `str`.\n    Returns:\n        Whether an `item` is a sequence.\n    \"\"\"\nif not inspect.isclass(item):\nitem = item.__class__\nreturn (\nissubclass(item, Sequence)\nand (not issubclass(item, str) or include_str))\n</code></pre>"},{"location":"reference/wonka/utilities/#wonka.utilities._iterify","title":"<code>_iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate <code>str</code> types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable.</p> required <p>Returns:</p> Type Description <code>Iterable</code> <p>Iterable of <code>item</code>. A <code>str</code> type will be stored as a single item in an iterable wrapper.</p> Source code in <code>src/wonka/utilities.py</code> <pre><code>def _iterify(item: Any) -&gt; Iterable:\n\"\"\"Returns `item` as an iterable, but does not iterate `str` types.\n    Args:\n        item: item to turn into an iterable.\n    Returns:\n        Iterable of `item`. A `str` type will be stored as a single item in an\n            iterable wrapper.\n    \"\"\"\nif item is None:\nreturn iter(())\nelif isinstance(item, str | bytes):\nreturn iter([item])\nelse:\ntry:\nreturn iter(item)\nexcept TypeError:\nreturn iter((item,))\n</code></pre>"},{"location":"reference/wonka/utilities/#wonka.utilities._namify","title":"<code>_namify(item, /, default=None)</code>","text":"<p>Returns <code>str</code> name representation of <code>item</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to determine a <code>str</code> name for.</p> required <code>default</code> <code>str | None</code> <p>default name to return if a name cannot be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>A name representation of <code>item.</code></p> Source code in <code>src/wonka/utilities.py</code> <pre><code>def _namify(item: Any, /, default: str | None = None) -&gt; str | None:\n\"\"\"Returns `str` name representation of `item`.\n    Args:\n        item: item to determine a `str` name for.\n        default: default name to return if a name cannot be created.\n    Returns:\n        A name representation of `item.`\n    \"\"\"\nif isinstance(item, str):\nreturn item\nelif (\nhasattr(item, 'name')\nand not inspect.isclass(item)\nand isinstance(item.name, str)):\nreturn item.name\nelse:\ntry:\nreturn _snakify(item.__name__)\nexcept AttributeError:\nif item.__class__.__name__ is not None:\nreturn _snakify(item.__class__.__name__)\nelse:\nreturn default\n</code></pre>"},{"location":"reference/wonka/utilities/#wonka.utilities._pathlibify","title":"<code>_pathlibify(item)</code>","text":"<p>Converts a <code>str</code> path to a <code>pathlib.Path</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>item to convert, if it is not already a <code>pathlib.Path</code> type.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>item</code> converted to <code>pathlib.Path</code>.</p> Source code in <code>src/wonka/utilities.py</code> <pre><code>def _pathlibify(item: str | pathlib.Path) -&gt; str:\n\"\"\"Converts a `str` path to a `pathlib.Path` type.\n    Args:\n        item: item to convert, if it is not already a `pathlib.Path` type.\n    Returns:\n        `item` converted to `pathlib.Path`.\n    Raises:\n        TypeError if `item` is neither a `str` or `Pathlib.Path` type.\n    \"\"\"\nif isinstance(item, pathlib.Path):\nreturn item\nelif isinstance(item, str):\nreturn pathlib.Path(item)\nelse:\nmessage = 'item must be a str or pathlib.Path type'\nraise TypeError(message)\n</code></pre>"},{"location":"reference/wonka/utilities/#wonka.utilities._snakify","title":"<code>_snakify(item)</code>","text":"<p>Converts a capitalized <code>str</code> to snake case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p><code>str</code> to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>item</code> converted to snake case.</p> Source code in <code>src/wonka/utilities.py</code> <pre><code>def _snakify(item: str) -&gt; str:\n\"\"\"Converts a capitalized `str` to snake case.\n    Args:\n        item: `str` to convert.\n    Returns:\n        `item` converted to snake case.\n    \"\"\"\nitem = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', item)\nreturn re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', item).lower()\n</code></pre>"}]}